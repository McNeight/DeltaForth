// <copyright file="CodeGenerator.cs" company="DeltaForth Contributors">
// Copyright © 1997-2011 Valer BOCAN
// Copyright © 2018 Neil McNeight
// All rights reserved.
// Licensed under the MIT license. See the LICENSE.markdown file in the project root for full license information.
// </copyright>

using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Reflection.Emit;
using System.Threading;

using DeltaForth.DataStructures;

namespace DeltaForth.CodeGen
{
    /// <summary>
    ///
    /// </summary>
    internal class CodeGenerator
    {
        #region Local variables

        /// <summary>
        /// Domain where we define the assemblies.
        /// </summary>
        private readonly AppDomain appDomain;

        /// <summary>
        /// Assembly name.
        /// </summary>
        private readonly AssemblyName assemblyName;

        /// <summary>
        /// Assembly.
        /// </summary>
        private readonly AssemblyBuilder assembly;

        /// <summary>
        /// Module builder.
        /// </summary>
        private readonly ModuleBuilder module;

        /// <summary>
        /// DeltaForthEngine type.
        /// </summary>
        private readonly TypeBuilder ForthEngineClass;

        private readonly List<MethodBuilder> Methods;   // Metods defined in the class
        private readonly CompilerMetadata MetaData;      // Compiler metadata (generated by the syntactic analyzer)
        private readonly MethodInfo StartupCode;            // Describes the pre-MAIN startup code
        private readonly string TargetFileName;         // Name of the target file (no path information)
        private readonly string TargetDirectory;            // Name of the target directory

        private readonly bool bExe;                     // TRUE if generating code for EXE, FALSE for DLL
        private readonly bool bCheckStack;              // TRUE if generating exception catching code for each method
        private bool bExtCallerDefined;         // TRUE if the runtime contains the ExternalCaller function

                                                // The function is generated in the runtime area at the first external call
        private MethodBuilder extCaller;        // ExternalCaller method builder

        #endregion

        #region Stacks

        private readonly int ForthStackOrigin;          // The Forth stack origin
        private FieldBuilder ForthStack;        // The Forth stack
        private FieldBuilder ForthStackIndex;   // The Forth stack index
        private readonly int ReturnStackOrigin;         // The return stack origin
        private FieldBuilder ReturnStack;       // The return stack
        private FieldBuilder ReturnStackIndex;  // The return stack index

        private readonly int ForthStackSize;        // The Forth stack size
        private readonly int ReturnStackSize;   // The Return stack size
        private readonly int Tib;               // TIB area offset
        private readonly int Pad;               // PAD area offset
        private readonly int LocalVarArea;      // A maximum of 1024 local variables can be defined

        #endregion

        #region Temporary variables

        private FieldBuilder Dummy1;            // Dummy variable, used for temporary storage
        private FieldBuilder Dummy2;            // Dummy variable, used for temporary storage
        private FieldBuilder Dummy3;            // Dummy variable, used for temporary storage
        private FieldBuilder strDummy;          // Dummy variable, used for temporary storage
        private FieldBuilder DoLoopDummy;       // Dummy variable, used for Do-LOOP/+LOOP structure

        #endregion

        #region Write methods (used when generating code that displays text)

        /// <summary>
        /// Describes the Write(string) method.
        /// </summary>
        private readonly MethodInfo WriteStringMethod;

        /// <summary>
        /// Describes the WriteLine(string) method.
        /// </summary>
        private readonly MethodInfo WriteLineStringMethod;

        /// <summary>
        /// Describes the Write(int) method.
        /// </summary>
        private readonly MethodInfo WriteIntMethod;

        /// <summary>
        /// Describes the Write(char) method.
        /// </summary>
        private readonly MethodInfo WriteCharMethod;

        #endregion

        #region Control structures stacks

        /// <summary>
        /// Stack for the IF-ELSE-THEN control structure.
        /// </summary>
        private readonly Stack<IFDescriptor> IFStack;

        /// <summary>
        /// Stack for the BEGIN-UNTIL control structure.
        /// </summary>
        private readonly Stack<BEGINDescriptor> BEGINStack;

        /// <summary>
        /// Stack for the CASE-ENDCASE control structure.
        /// </summary>
        private readonly Stack<Label> CASEStack;

        /// <summary>
        /// Stack for the DO-LOOP/+LOOP control structure.
        /// </summary>
        private readonly Stack<DODescriptor> DOStack;

        #endregion

        public CodeGenerator(CompilerMetadata MetaData, string TargetFileName, string TargetDirectory, string SignatureFileName, bool GenerateExecutable, bool GenerateStackFrames, int ForthStackSize, int ReturnStackSize)
        {
            // Initialize variables
            this.TargetFileName = TargetFileName;
            this.TargetDirectory = TargetDirectory;
            this.MetaData = MetaData;
            this.bExe = GenerateExecutable;
            this.bCheckStack = GenerateStackFrames;
            this.bExtCallerDefined = false;

            // Set stack sizes
            this.ForthStackSize = ForthStackSize;
            this.ReturnStackSize = ReturnStackSize;

            // Set system variables
            this.Tib = ForthStackSize - 64 - 80;
            this.Pad = ForthStackSize - 64;
            this.LocalVarArea = ForthStackSize - 64 - 80 - 1024;

            // Initialize stack origins
            this.ForthStackOrigin = 0;
            this.ReturnStackOrigin = 0;

            // Initialize Write methods
            this.WriteStringMethod = typeof(Console).GetMethod("Write", new Type[] { typeof(string) });
            this.WriteLineStringMethod = typeof(Console).GetMethod("WriteLine", new Type[] { typeof(string) });
            this.WriteIntMethod = typeof(Console).GetMethod("Write", new Type[] { typeof(int) });
            this.WriteCharMethod = typeof(Console).GetMethod("Write", new Type[] { typeof(char) });

            // Initialize stacks
            this.IFStack = new Stack<IFDescriptor>();
            this.BEGINStack = new Stack<BEGINDescriptor>();
            this.CASEStack = new Stack<Label>();
            this.DOStack = new Stack<DODescriptor>();

            // Initialize address of global variables
            for (var i = 0; i < MetaData.GlobalVariables.Count; i++)
            {
                var fv = MetaData.GlobalVariables[i];
                fv.Address = this.ForthStackOrigin;
                this.ForthStackOrigin += fv.Size;       // Advance the stack origin to accomodate the variable size
                MetaData.GlobalVariables[i] = fv;
            }

            this.Methods = new List<MethodBuilder>();

            // ...

            this.appDomain = Thread.GetDomain();                // Initialize domain

            this.assemblyName = new AssemblyName
            {
                Name = "DeltaForthEngine",
            };         // Create an assembly name

            // Sign assembly (if the p_SignatureFileName parameter is not empty)
            if (SignatureFileName != string.Empty)
            {
                try
                {
                    var fs = new FileStream(SignatureFileName, FileMode.Open);
                    var kp = new StrongNameKeyPair(fs);

                    // The line below will throw an exception if the file does not
                    // contain a valid key
                    var PublicKey = kp.PublicKey.ToString();
                    fs.Close();
                    this.assemblyName.KeyPair = kp;
                }
                catch (FileNotFoundException)
                {
                    throw new Exception("Signature file " + SignatureFileName + " is missing.");
                }
                catch (Exception)
                {
                    throw new Exception("Signature file " + SignatureFileName + " is invalid.");
                }
            }

            // Create the assembly
            this.assembly = this.appDomain.DefineDynamicAssembly(this.assemblyName, AssemblyBuilderAccess.Save, TargetDirectory);

            // Create a module within the assembly
            this.module = this.assembly.DefineDynamicModule("DeltaForthModule", TargetFileName);

            // Define a public class
            var LibraryName = "DeltaForthEngine";   // Default class name
            if (!string.IsNullOrEmpty(MetaData.LibraryName))
            {
                LibraryName = MetaData.LibraryName;
            }

            this.ForthEngineClass = this.module.DefineType(LibraryName, TypeAttributes.Public | TypeAttributes.BeforeFieldInit);

            // Create the class constructor
            Type[] constructorArgs = { };
            var constructor = this.ForthEngineClass.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, constructorArgs);

            // Create the method "InitForthEngine" to initialize the Forth environment
            this.StartupCode = this.CreateStartupCode();

            // Generate IL code for the constructor
            var constructorIL = constructor.GetILGenerator();
            constructorIL.Emit(OpCodes.Ldarg_0);
            var superConstructor = typeof(object).GetConstructor(new Type[0]);
            constructorIL.Emit(OpCodes.Call, superConstructor);
            constructorIL.Emit(OpCodes.Ret);
        }

        // CreateStartupCode - Creates a function that initializes the Forth stack, the return stack, system variables, etc.
        // Input:  None
        // Output: A MethodBuilder structure describing the pre-MAIN start-up code
        private MethodBuilder CreateStartupCode()
        {
            // Initialize the Forth stack
            this.ForthStack = this.ForthEngineClass.DefineField("ForthStack", typeof(int[]), FieldAttributes.Public | FieldAttributes.Static);
            this.ForthStackIndex = this.ForthEngineClass.DefineField("ForthStackIndex", typeof(int), FieldAttributes.Public | FieldAttributes.Static);

            // Initialize the return stack
            this.ReturnStack = this.ForthEngineClass.DefineField("ReturnStack", typeof(int[]), FieldAttributes.Private | FieldAttributes.Static);
            this.ReturnStackIndex = this.ForthEngineClass.DefineField("ReturnStackIndex", typeof(int), FieldAttributes.Private | FieldAttributes.Static);

            // Initialize dummy fields
            this.Dummy1 = this.ForthEngineClass.DefineField("dummy1", typeof(int), FieldAttributes.Private | FieldAttributes.Static);
            this.Dummy2 = this.ForthEngineClass.DefineField("dummy2", typeof(int), FieldAttributes.Private | FieldAttributes.Static);
            this.Dummy3 = this.ForthEngineClass.DefineField("dummy3", typeof(int), FieldAttributes.Private | FieldAttributes.Static);
            this.strDummy = this.ForthEngineClass.DefineField("strdummy", typeof(string), FieldAttributes.Private | FieldAttributes.Static);
            this.DoLoopDummy = this.ForthEngineClass.DefineField("dummy4", typeof(int), FieldAttributes.Private | FieldAttributes.Static);

            // Create the InitEngine method
            var InitMethod = this.ForthEngineClass.DefineMethod("InitEngine", MethodAttributes.Private | MethodAttributes.Static, typeof(void), null);
            var ilgen = InitMethod.GetILGenerator();

            // Initialize ForthStack array
            ilgen.Emit(OpCodes.Ldc_I4, this.ForthStackSize);
            ilgen.Emit(OpCodes.Newarr, typeof(int));    // Was "int[]". Thanks to Brad Merrill from Microsoft.
            ilgen.Emit(OpCodes.Stsfld, this.ForthStack);

            // Initialize ReturnStack array
            ilgen.Emit(OpCodes.Ldc_I4, this.ReturnStackSize);
            ilgen.Emit(OpCodes.Newarr, typeof(int));    // Was "int[]". Thanks to Brad Merrill from Microsoft.
            ilgen.Emit(OpCodes.Stsfld, this.ReturnStack);

            // Initialize ForthStackIndex to origin
            ilgen.Emit(OpCodes.Ldc_I4, this.ForthStackOrigin);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);

            // Normal return from function
            ilgen.Emit(OpCodes.Ret);

            return InitMethod;
        }

        // SetEntryPoint - Sets the starting point of the program
        // Input:  The name of the method that starts the program
        // Output: None
        private void SetEntryPoint(string MethodName)
        {
            // Setup program entry point (MAIN code)
            var entrypoint = this.GetMethod(MethodName).GetBaseDefinition();

            // No MAIN function defined
            if (entrypoint == null)
            {
                entrypoint = this.StartupCode;  // Execution begins with the startup code
            }

            this.assembly.SetEntryPoint(entrypoint, PEFileKinds.ConsoleApplication);

            // NOTE:
            // DF versions prior to 1.0 beta 2b used the line below to set up the entry point
            // of the DLL. With the advent of the .NET Framework RC, this technique didn't work
            // any more, since a DLL initialization exception occurs at runtime.
            // assembly.SetEntryPoint(entrypoint, PEFileKinds.Dll);
        }

        // AddMethod - Builds a method and adds it to the DeltaForthEngine class
        // Input:  MethodName - the name of the method
        // Output: A MethodBuilder structure
        private MethodBuilder AddMethod(string MethodName)
        {
            var ForthMethod = this.ForthEngineClass.DefineMethod(MethodName, MethodAttributes.Public | MethodAttributes.Static, typeof(void), null);
            this.Methods.Add(ForthMethod);  // Add method builder to our list
            return ForthMethod;
        }

        // GetMethod - Gets the information for a specified method
        // Input:  MethodName - the name of the method
        // Output: A MethodBuilder structure
        private MethodBuilder GetMethod(string MethodName)
        {
            return this.Methods.Find(m => m.Name.ToUpper() == MethodName.ToUpper());
        }

        // DoGenerateCode - Generates code out of available words
        // Input:  None
        // Output: None
        public void DoGenerateCode()
        {
            // Add all words to the module
            foreach (var word in this.MetaData.Words)
            {
                this.AddMethod(word.Name);
            }

            // Generate the code for each method (Forth word)
            foreach (var word in this.MetaData.Words)
            {
                var mb = this.GetMethod(word.Name);
                this.GenerateMethodCode(mb);
            }

            // Save the assembly
            this.SetEntryPoint("MAIN");
            this.SaveAssembly();
        }

        // SaveAssembly - Saves the generated code to target file
        // Input:  None
        // Output: None
        private void SaveAssembly()
        {
            try
            {
                this.ForthEngineClass.CreateType();
                this.assembly.Save(this.TargetFileName);
            }
            catch (Exception ex)
            {
                var Target = Path.Combine(this.TargetDirectory, this.TargetFileName);
                throw new Exception("Could not write the output file to '" + Target + "'. Reason: " + ex.Message);
            }
        }

        // GenerateMethodCode - Generate the code of the specified method
        // Input:  None
        // Output: None
        private void GenerateMethodCode(MethodBuilder mb)
        {
            var MethodName = mb.Name;
            var MethodILGen = mb.GetILGenerator();

            // Initialize address of local variables for the current method
            for (var i = 0; i < this.MetaData.LocalVariables.Count; i++)
            {
                var fv = this.MetaData.LocalVariables[i];
                if (fv.WordName == MethodName)
                {
                    fv.Address = this.LocalVarArea + i;
                    this.MetaData.LocalVariables[i] = fv;
                }
            }

            // If we are generating code for the MAIN function, we should call the startup code first
            if (MethodName == "MAIN")
            {
                MethodILGen.Emit(OpCodes.Call, this.StartupCode);
            }

            // Each method should catch exceptions thrown by stack operations
            if (this.bCheckStack)
            {
                MethodILGen.BeginExceptionBlock();
            }

            // We have the method name, now look for the contents of the word
            var WordContents = this.MetaData.Words.Find(w => w.Name.ToUpper() == MethodName.ToUpper()).Definition;

            // The contents of the 'MethodName' word is now in the 'WordContents' list
            foreach (var at in WordContents)
            {
                // Get the current atom
                var atom = at;

                // Display statement ( ."<text>" )
                if (atom.StartsWith(".\""))
                {
                    atom = atom.Remove(0, 2);                       // Remove ."
                    atom = atom.TrimEnd(new char[] { '\"' });           // Remove trailing "
                    MethodILGen.Emit(OpCodes.Ldstr, atom);              // ldstr "text"
                    MethodILGen.Emit(OpCodes.Call, this.WriteStringMethod); // call WriteLine(string)
                    continue;
                }

                // Dump statement ( "<text>")
                if (atom.StartsWith("\""))
                {
                    atom = atom.Trim(new char[] { '\"' });            // Remove " from the beginning and the end of the string
                    this._Dump(MethodILGen, atom);              // Dump the string at the address specified on the stack
                    continue;
                }

                switch (atom)
                {
                    case "+": // "+" - adds two numbers on the stack
                        this.MathOp(MethodILGen, '+');
                        break;
                    case "-": // "-" - adds two numbers on the stack
                        this.MathOp(MethodILGen, '-');
                        break;
                    case "*": // "*" - adds two numbers on the stack
                        this.MathOp(MethodILGen, '*');
                        break;
                    case "/": // "/" - adds two numbers on the stack
                        this.MathOp(MethodILGen, '/');
                        break;
                    case "MOD": // "MOD" - division remainder
                        this.MathOp(MethodILGen, '%');
                        break;
                    case "/MOD": // "Slash MOD" - division remainder and result
                        this._SlashMod(MethodILGen);
                        break;
                    case "*/": // "Star Slash" - scaling operator
                        this._StarSlash(MethodILGen);
                        break;
                    case "*/MOD": // "Star Slash Mod" - scaling operator
                        this._StarSlashMod(MethodILGen);
                        break;
                    case "MINUS": // "Minus" - minus
                        this._Minus(MethodILGen);
                        break;
                    case "ABS": // "Absolute" - absolute value
                        this._Abs(MethodILGen);
                        break;
                    case "MIN": // "MIN" - minimum of two values
                        this._MinMax(MethodILGen, true);
                        break;
                    case "MAX": // "MAX" - maximum of two values
                        this._MinMax(MethodILGen, false);
                        break;
                    case "1+": // "One Plus" - adds 1 to the value on top of stack
                        this._OnePlus(MethodILGen);
                        break;
                    case "2+": // "Two Plus" - adds 2 to the value on top of stack
                        this._TwoPlus(MethodILGen);
                        break;
                    case "0=": // "Zero Equal" - test for equality with 0
                        this._ZeroEqual(MethodILGen);
                        break;
                    case "0<": // "Zero Less" - test for 0 or less
                        this._ZeroLess(MethodILGen);
                        break;
                    case "=": // "Equal" - test for equal
                        this._Equal(MethodILGen);
                        break;
                    case "<": // "Less" - test for less
                        this._Less(MethodILGen);
                        break;
                    case ">": // "Greater" - test for greater
                        this._Greater(MethodILGen);
                        break;
                    case "<>": // "Not equal" - test for not-equal
                        this._NotEqual(MethodILGen);
                        break;
                    case "~AND": // Bitwise AND
                        this._BitwiseOp(MethodILGen, '&');
                        break;
                    case "~OR": // Bitwise OR
                        this._BitwiseOp(MethodILGen, '|');
                        break;
                    case "~XOR": // Bitwise XOR
                        this._BitwiseOp(MethodILGen, '^');
                        break;
                    case "~NOT": // Bitwise NOT
                        this._BitwiseNOT(MethodILGen);
                        break;
                    case "AND": // Logical AND
                        this._LogicalAND(MethodILGen);
                        break;
                    case "OR": // Logical OR
                        this._LogicalOR(MethodILGen);
                        break;
                    case "NOT": // Logical NOT
                        this._LogicalNOT(MethodILGen);
                        break;
                    case "DUP": // Duplicates the value on top of stack
                        this._Dup(MethodILGen);
                        break;
                    case "-DUP": // Duplicates the value on top of stack unless it is 0
                        this._DashDup(MethodILGen);
                        break;
                    case "DROP": // Removes the value on top of stack
                        this._Drop(MethodILGen);
                        break;
                    case "SWAP": // Swaps the topmost two values on the stack
                        this._Swap(MethodILGen);
                        break;
                    case "OVER": // Duplicates the second value on the stack
                        this._Over(MethodILGen);
                        break;
                    case "ROT": // Rotates top three elements on the stack
                        this._Rot(MethodILGen);
                        break;
                    case "SP@": // Stack pointer fetch
                        this._SPfetch(MethodILGen);
                        break;
                    case "RP@": // Return stack pointer fetch
                        this._RPfetch(MethodILGen);
                        break;
                    case "SP!": // Flush Forth stack
                        this._SPstore(MethodILGen);
                        break;
                    case "RP!": // Flush return stack
                        this._RPstore(MethodILGen);
                        break;
                    case "@": // Fetch
                        this._Fetch(MethodILGen);
                        break;
                    case "?": // Question-mark
                        this._QuestionMark(MethodILGen);
                        break;
                    case "!": // Store
                        this._Store(MethodILGen);
                        break;
                    case "+!": // Plus store
                        this._PlusStore(MethodILGen);
                        break;
                    case "EMIT": // Emit
                        this._Emit(MethodILGen);
                        break;
                    case ".":
                        // October 18, 2003
                        // Added stack bounds verification for the . word
                        if (this.bCheckStack)
                        {
                            var lb1 = MethodILGen.DefineLabel();
                            MethodILGen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
                            MethodILGen.Emit(OpCodes.Ldc_I4, this.ForthStackOrigin);
                            MethodILGen.Emit(OpCodes.Bgt_S, lb1);

                            // Throw exception (stack underflow)
                            MethodILGen.ThrowException(typeof(System.IndexOutOfRangeException));
                            MethodILGen.MarkLabel(lb1);
                        }

                        MethodILGen.Emit(OpCodes.Ldsfld, this.ForthStack);
                        MethodILGen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
                        MethodILGen.Emit(OpCodes.Ldc_I4_1);
                        MethodILGen.Emit(OpCodes.Sub);
                        MethodILGen.Emit(OpCodes.Dup);
                        MethodILGen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
                        MethodILGen.Emit(OpCodes.Ldelem_I4);
                        MethodILGen.Emit(OpCodes.Call, this.WriteIntMethod);    // call WriteLine(int)
                        break;
                    case "CR": // CR - moves the cursor to the beginning of the next line
                        MethodILGen.Emit(OpCodes.Ldstr, string.Empty);                // ldstr ""
                        MethodILGen.Emit(OpCodes.Call, this.WriteLineStringMethod); // call WriteLine(string)
                        break;
                    case "SPACE": // SPACE - displays an empty space on the screen
                        MethodILGen.Emit(OpCodes.Ldstr, " ");               // ldstr " "
                        MethodILGen.Emit(OpCodes.Call, this.WriteStringMethod); // call WriteLine(string)
                        break;
                    case "SPACES": // SPACES - displays a number of space on the screen
                        this._Spaces(MethodILGen);
                        break;
                    case "TYPE": // TYPE - Types a text on the screen
                        this._Type(MethodILGen);
                        break;
                    case "PAD": // PAD - 64-cell area
                        this._Pad(MethodILGen);
                        break;
                    case "TIB": // TIB - 80-cell area
                        this._Tib(MethodILGen);
                        break;
                    case "S0": // Forth stack origin
                        this._StackOrigin(MethodILGen, true);
                        break;
                    case "R0": // Return stack origin
                        this._StackOrigin(MethodILGen, false);
                        break;
                    case "KEY": // KEY - Places the key code on the stack
                        this._Key(MethodILGen);
                        break;
                    case "EXPECT":
                        this._Expect(MethodILGen);
                        break;
                    case "QUERY":
                        this._Query(MethodILGen);
                        break;
                    case ">R":
                        this._ToR(MethodILGen);
                        break;
                    case "R>":
                        this._RFrom(MethodILGen);
                        break;
                    case "I":
                        this._I(MethodILGen);
                        break;
                    case "I'":
                        this._Isecond(MethodILGen);
                        break;
                    case "J":
                        this._J(MethodILGen);
                        break;
                    case "FILL":
                        this._Fill(MethodILGen);
                        break;
                    case "ERASE":
                        this._Erase(MethodILGen, 0);
                        break;
                    case "BLANKS":
                        this._Erase(MethodILGen, 32);
                        break;
                    case "STR2INT":
                        this._Str2Int(MethodILGen);
                        break;
                    case "COUNT":
                        this._Count(MethodILGen);
                        break;
                    case "CMOVE":
                        this._CMove(MethodILGen);
                        break;
                    case "INT2STR":
                        this._Int2Str(MethodILGen);
                        break;
                    case "EXIT":
                        this._Exit(MethodILGen);
                        break;
                    case "IF":
                        this._If(MethodILGen);
                        break;
                    case "ELSE":
                        this._Else(MethodILGen);
                        break;
                    case "THEN":
                        this._Then(MethodILGen);
                        break;
                    case "BEGIN":
                        this._Begin(MethodILGen);
                        break;
                    case "UNTIL":
                        this._Until(MethodILGen);
                        break;
                    case "AGAIN":
                        this._Again(MethodILGen);
                        break;
                    case "WHILE":
                        this._While(MethodILGen);
                        break;
                    case "REPEAT":
                        this._Repeat(MethodILGen);
                        break;
                    case "CASE":
                        this._Case(MethodILGen);
                        break;
                    case "OF":
                        this._Of(MethodILGen);
                        break;
                    case "ENDOF":
                        this._EndOf(MethodILGen);
                        break;
                    case "ENDCASE":
                        this._EndCase(MethodILGen);
                        break;
                    case "DO":
                        this._Do(MethodILGen);
                        break;
                    case "LEAVE":
                        this._Leave(MethodILGen);
                        break;
                    case "LOOP":
                        this._Loop(MethodILGen);
                        break;
                    case "+LOOP":
                        this._PlusLoop(MethodILGen);
                        break;
                    default:
                        try
                        {
                            // Try to push the atom onto the stack (hoping that it is a number)
                            this._PushStack(MethodILGen, Convert.ToInt32(atom, 10));
                            break;
                        }
                        catch (Exception)
                        {
                            // It's not a number, swallow the error and continue checking
                        }

                        // Check whether the atom is a constant
                        var GlobalConstant = this.MetaData.GlobalConstants.Find(c => c.Name.ToUpper() == atom);
                        if (GlobalConstant != null)
                        {
                            if (GlobalConstant.Value.GetType() == typeof(int))
                            {
                                // The constant is of integer type
                                this._PushStack(MethodILGen, (int)GlobalConstant.Value);
                            }
                            else
                            {
                                // The constant is of string type
                                this._Dump(MethodILGen, (string)GlobalConstant.Value);
                            }

                            break;
                        }

                        // Check whether the atom is a local variable
                        var LocalVar = this.MetaData.LocalVariables.Find(v => v.Name.ToUpper() == atom && v.WordName.ToUpper() == MethodName);
                        if (LocalVar != null)
                        {
                            var varaddr = LocalVar.Address.ToString();
                            this._PushStack(MethodILGen, Convert.ToInt32(varaddr, 10));
                            break;
                        }

                        // Check whether the atom is a variable
                        var GlobalVar = this.MetaData.GlobalVariables.Find(v => v.Name.ToUpper() == atom);
                        if (GlobalVar != null)
                        {
                            var varaddr = GlobalVar.Address.ToString();
                            this._PushStack(MethodILGen, Convert.ToInt32(varaddr, 10));
                            break;
                        }

                        // Check whether the atom is an external word
                        var ExternalWord = this.MetaData.ExternalWords.Find(v => v.Name.ToUpper() == atom);
                        if (ExternalWord != null)
                        {
                            this.CallExternalMethod(MethodILGen, ExternalWord.Library, ExternalWord.Class, ExternalWord.Method);
                            break;
                        }

                        // Finally, if it's not a known word, then raise and error
                        var lmb = this.GetMethod(atom);
                        if (lmb != null)
                        {
                            // It must be a word we're dealing with
                            MethodILGen.Emit(OpCodes.Call, this.GetMethod(atom));   // Call function
                        }
                        else
                        {
                            throw new Exception(atom + " in word " + MethodName + " is not known.");
                        }

                        break;
                }
            }

            // Catch the index out of bounds exception
            if (this.bCheckStack)
            {
                MethodILGen.BeginCatchBlock(typeof(IndexOutOfRangeException));
                MethodILGen.Emit(OpCodes.Pop);

                // If exception occured in MAIN, simply display an error message and return
                if (MethodName == "MAIN")
                {
                    MethodILGen.EmitWriteLine("RUNTIME ERROR: Stack underflow or overflow.");
                }
                else
                {
                    // If the exception occured in some method, rethrow the exception to MAIN
                    MethodILGen.ThrowException(typeof(IndexOutOfRangeException));
                }

                // Catch the file not found exception (thrown by ExternalCaller)
                MethodILGen.BeginCatchBlock(typeof(System.IO.FileNotFoundException));
                MethodILGen.Emit(OpCodes.Pop);
                MethodILGen.EmitWriteLine("RUNTIME ERROR: Library file not found.");
                MethodILGen.EndExceptionBlock();
            }

            // Every function ends with the RET statement
            MethodILGen.Emit(OpCodes.Ret);
        }

        // MathOp - Generates code for operations +, -, *, /
        //      ForthStack[ForthStackIndex - 2] = ForthStack[ForthStackIndex - 2] "MathOp" ForthStack[ForthStackIndex - 1];
        // ForthStackIndex--;
        // Input:  ILGenerator for the method, operation to perform
        // Output: None
        private void MathOp(ILGenerator ilgen, char Op)
        {
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);

            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);

            // -------------------------
            switch (Op)
            {
                case '+':
                    ilgen.Emit(OpCodes.Add);
                    break;
                case '-':
                    ilgen.Emit(OpCodes.Sub);
                    break;
                case '*':
                    ilgen.Emit(OpCodes.Mul);
                    break;
                case '/':
                    ilgen.Emit(OpCodes.Div);
                    break;
                case '%':
                    ilgen.Emit(OpCodes.Rem);
                    break;
            }

            // -------------------------
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
        }

        // _PushStack - Push a value on the stack
        // ForthStack[ForthStackIndex++] = "value";
        // Input:  ILGenerator for the method, value to push
        // Output: None
        private void _PushStack(ILGenerator ilgen, int value)
        {
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4, value);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _SlashMod - Division remainder and result
        // Dummy1 = ForthStack[ForthStackIndex - 1];
        // Dummy2 = ForthStack[ForthStackIndex - 2];
        // ForthStack[ForthStackIndex - 2] = Dummy2 % Dummy1;
        // ForthStack[ForthStackIndex - 1] = Dummy2 / Dummy1;
        // Input:  ILGenerator for the method
        // Output: None
        private void _SlashMod(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Rem);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Div);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _StarSlash - Scaling operator
        // Dummy1 = ForthStack[ForthStackIndex - 1];
        // Dummy2 = ForthStack[ForthStackIndex - 2];
        // Dummy3 = ForthStack[ForthStackIndex - 3];
        // ForthStackIndex-=2;
        // ForthStack[ForthStackIndex - 1] = Dummy3 * Dummy2 / Dummy1;
        // Input:  ILGenerator for the method
        // Output: None
        private void _StarSlash(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_3);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy3);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy3);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Mul);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Div);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _StarSlashMod - Scaling operator
        // Dummy1 = ForthStack[ForthStackIndex - 1];
        // Dummy2 = ForthStack[ForthStackIndex - 2];
        // Dummy3 = ForthStack[ForthStackIndex - 3];
        // ForthStackIndex--;
        // ForthStack[ForthStackIndex - 2] = (Dummy3 * Dummy2) % Dummy1;
        // ForthStack[ForthStackIndex - 1] = Dummy3 * Dummy2 / Dummy1;
        // Input:  ILGenerator for the method
        // Output: None
        private void _StarSlashMod(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_3);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy3);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy3);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Mul);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Rem);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy3);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Mul);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Div);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _Minus - Changes the sign of the number on top of stack
        // ForthStack[ForthStackIndex - 1] = - ForthStack[ForthStackIndex - 1];
        // Input:  ILGenerator for the method
        // Output: None
        private void _Minus(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Neg);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _Abs - Absolute value of number
        //
        // Input:  ILGenerator for the method
        // ForthStack[ForthStackIndex - 1] = Math.Abs(ForthStack[ForthStackIndex - 1]);
        // Output: None
        private void _Abs(ILGenerator ilgen)
        {
            var Abs = typeof(Math).GetMethod("Abs", new Type[] { typeof(int) });

            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Call, Abs);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _MinMax - Minimum and maximum value
        //
        // Input:  ILGenerator for the method
        // Minimum - true if minimum is to calculated, false for maximum
        // ForthStack[ForthStackIndex - 1] = Math.Min(ForthStack[ForthStackIndex - 1]);
        // ForthStackIndex--;
        // Output: None
        private void _MinMax(ILGenerator ilgen, bool Minimum)
        {
            var Min = typeof(Math).GetMethod("Min", new Type[] { typeof(int), typeof(int) });
            var Max = typeof(Math).GetMethod("Max", new Type[] { typeof(int), typeof(int) });

            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            if (Minimum)
            {
                ilgen.Emit(OpCodes.Call, Min);
            }
            else
            {
                ilgen.Emit(OpCodes.Call, Max);
            }

            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
        }

        // _OnePlus - Adds 1 to the value on top of stack
        //
        // Input:  ILGenerator for the method
        // ForthStack[ForthStackIndex - 1] = ForthStack[ForthStackIndex - 1] + 1;
        // Output: None
        private void _OnePlus(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _TwoPlus - Adds 2 to the value on top of stack
        //
        // Input:  ILGenerator for the method
        // ForthStack[ForthStackIndex - 1] = ForthStack[ForthStackIndex - 1] + 2;
        // Output: None
        private void _TwoPlus(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _ZeroEqual - Test for "zero-equal"
        //
        // Input:  ILGenerator for the method
        // ForthStack[ForthStackIndex - 1] = (ForthStack[ForthStackIndex - 1] == 0) ? 1 : 0;
        // Output: None
        private void _ZeroEqual(ILGenerator ilgen)
        {
            var lbZero = ilgen.DefineLabel();
            var lbOne = ilgen.DefineLabel();

            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);

            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);

            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Brfalse_S, lbOne);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Br_S, lbZero);
            ilgen.MarkLabel(lbOne);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.MarkLabel(lbZero);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _ZeroLess - Test for "zero or less"
        // Input:  ILGenerator for the method
        // ForthStack[ForthStackIndex - 1] = (ForthStack[ForthStackIndex - 1] <= 0) ? 1 : 0;
        // Output: None
        private void _ZeroLess(ILGenerator ilgen)
        {
            var lbZero = ilgen.DefineLabel();
            var lbOne = ilgen.DefineLabel();

            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Ble_S, lbOne);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Br_S, lbZero);
            ilgen.MarkLabel(lbOne);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.MarkLabel(lbZero);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _Equal - Test for "equal"
        // Input:  ILGenerator for the method
        // ForthStack[ForthStackIndex - 2] = (ForthStack[ForthStackIndex - 1] == ForthStack[ForthStackIndex - 2]) ? 1 : 0;
        // ForthStackIndex--;
        // Output: None
        private void _Equal(ILGenerator ilgen)
        {
            var lb1 = ilgen.DefineLabel();
            var lb2 = ilgen.DefineLabel();

            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Beq_S, lb1);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Br_S, lb2);
            ilgen.MarkLabel(lb1);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.MarkLabel(lb2);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
        }

        // _Less - Test for "less"
        // Input:  ILGenerator for the method
        // ForthStack[ForthStackIndex - 2] = (ForthStack[ForthStackIndex - 2] < ForthStack[ForthStackIndex - 1]) ? 1 : 0;
        // ForthStackIndex--;
        // Output: None
        private void _Less(ILGenerator ilgen)
        {
            var lb1 = ilgen.DefineLabel();
            var lb2 = ilgen.DefineLabel();

            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Blt_S, lb1);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Br_S, lb2);
            ilgen.MarkLabel(lb1);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.MarkLabel(lb2);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
        }

        // _Greater - Test for "greater"
        // Input:  ILGenerator for the method
        // ForthStack[ForthStackIndex - 2] = (ForthStack[ForthStackIndex - 2] > ForthStack[ForthStackIndex - 1]) ? 1 : 0;
        // ForthStackIndex--;
        // Output: None
        private void _Greater(ILGenerator ilgen)
        {
            var lb1 = ilgen.DefineLabel();
            var lb2 = ilgen.DefineLabel();

            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Bgt_S, lb1);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Br_S, lb2);
            ilgen.MarkLabel(lb1);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.MarkLabel(lb2);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
        }

        // _NotEqual - Test for "not equal"
        // Input:  ILGenerator for the method
        // ForthStack[ForthStackIndex - 2] = (ForthStack[ForthStackIndex - 2] <> ForthStack[ForthStackIndex - 1]) ? 1 : 0;
        // ForthStackIndex--;
        // Output: None
        private void _NotEqual(ILGenerator ilgen)
        {
            var lb1 = ilgen.DefineLabel();
            var lb2 = ilgen.DefineLabel();

            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Bne_Un_S, lb1);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Br_S, lb2);
            ilgen.MarkLabel(lb1);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.MarkLabel(lb2);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
        }

        // _BitwiseOp - Bitwise operations (AND, OR, XOR)
        // Input:  ILGenerator for the method
        // ForthStack[ForthStackIndex - 2] = ForthStack[ForthStackIndex - 2] "op" ForthStack[ForthStackIndex - 1];
        // ForthStackIndex--;
        // Output: None
        private void _BitwiseOp(ILGenerator ilgen, char Op)
        {
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            switch (Op)
            {
                case '&':
                    ilgen.Emit(OpCodes.And);
                    break;
                case '|':
                    ilgen.Emit(OpCodes.Or);
                    break;
                case '^':
                    ilgen.Emit(OpCodes.Xor);
                    break;
            }

            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
        }

        // _BitwiseNOT - Bitwise NOT
        // Input:  ILGenerator for the method
        // ForthStack[ForthStackIndex - 1] = ~ForthStack[ForthStackIndex - 1];
        // Output: None
        private void _BitwiseNOT(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Not);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _LogicalAND - Logical AND
        // Input:  ILGenerator for the method
        // ForthStack[ForthStackIndex - 2] = ((ForthStack[ForthStackIndex - 2] > 0) && (ForthStack[ForthStackIndex - 1] > 0) ? 1 : 0);
        // ForthStackIndex--;
        // Output: None
        private void _LogicalAND(ILGenerator ilgen)
        {
            var lb1 = ilgen.DefineLabel();
            var lb2 = ilgen.DefineLabel();
            var lb3 = ilgen.DefineLabel();

            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Ble_S, lb1);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Bgt_S, lb2);
            ilgen.MarkLabel(lb1);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Br_S, lb3);
            ilgen.MarkLabel(lb2);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.MarkLabel(lb3);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
        }

        // _LogicalOR - Logical OR
        // Input:  ILGenerator for the method
        // ForthStack[ForthStackIndex - 2] = ((ForthStack[ForthStackIndex - 2] > 0) || (ForthStack[ForthStackIndex - 1] > 0) ? 1 : 0);
        // ForthStackIndex--;
        // Output: None
        private void _LogicalOR(ILGenerator ilgen)
        {
            var lb1 = ilgen.DefineLabel();
            var lb2 = ilgen.DefineLabel();
            var lb3 = ilgen.DefineLabel();

            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Bgt_S, lb1);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Bgt_S, lb1);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Br_S, lb2);
            ilgen.MarkLabel(lb1);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.MarkLabel(lb2);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
        }

        // _LogicalNOT - Logical NOT
        // Input:  ILGenerator for the method
        // ForthStack[ForthStackIndex - 1] = (ForthStack[ForthStackIndex - 1] != 0) ? 0 : 1;
        // Output: None
        private void _LogicalNOT(ILGenerator ilgen)
        {
            var lb1 = ilgen.DefineLabel();
            var lb2 = ilgen.DefineLabel();

            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Brtrue_S, lb1);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Br_S, lb2);
            ilgen.MarkLabel(lb1);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.MarkLabel(lb2);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _Dup - Duplicates the element on top of stack
        // Input:  ILGenerator for the method
        // ForthStack[ForthStackIndex] = ForthStack[ForthStackIndex - 1];
        // ForthStackIndex++;
        // Output: None
        private void _Dup(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
        }

        // _DashDup - Duplicates the element on top of stack unless it is 0
        // Input:  ILGenerator for the method
        // if(ForthStack[ForthStackIndex - 1] != 0) ForthStack[ForthStackIndex] = ForthStack[ForthStackIndex - 1];
        // ForthStackIndex++;
        // Output: None
        private void _DashDup(ILGenerator ilgen)
        {
            var lb = ilgen.DefineLabel();

            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Brfalse_S, lb);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
            ilgen.MarkLabel(lb);
            ilgen.Emit(OpCodes.Nop);
        }

        // _Drop - Removes the element on top of stack
        // Input:  ILGenerator for the method
        // ForthStackIndex--;
        // Output: None
        private void _Drop(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
        }

        // _Swap - Swaps the two elements on the top of stack
        // Input:  ILGenerator for the method
        // Dummy1 = ForthStack[ForthStackIndex - 1];
        // ForthStack[ForthStackIndex - 1] = ForthStack[ForthStackIndex - 2];
        // ForthStack[ForthStackIndex - 2] = Dummy1;
        // Output: None
        private void _Swap(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _Over - Duplicates the second value on the stack
        // Input:  ILGenerator for the method
        // ForthStack[ForthStackIndex] = ForthStack[ForthStackIndex - 2];
        // ForthStackIndex++;
        // Output: None
        private void _Over(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
        }

        // _Rot
        // Input:  ILGenerator for the method
        // Dummy1 = ForthStack[ForthStackIndex - 3];
        // ForthStack[ForthStackIndex - 3] = ForthStack[ForthStackIndex - 2];
        // ForthStack[ForthStackIndex - 2] = ForthStack[ForthStackIndex - 1];
        // ForthStack[ForthStackIndex - 1] = Dummy1;
        // Output: None
        private void _Rot(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_3);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_3);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _SPfetch - Current Forth stack index
        // Input:  ILGenerator for the method
        // ForthStack[ForthStackIndex] = ForthStackIndex;
        // ForthStackIndex++;
        // Output: None
        private void _SPfetch(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
        }

        // _RPfetch - Current return stack index
        // Input:  ILGenerator for the method
        // ForthStack[ForthStackIndex] = ReturnStackIndex;
        // ForthStackIndex++;
        // Output: None
        private void _RPfetch(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldsfld, this.ReturnStackIndex);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
        }

        // _SPstore - Flush Forth stack
        // Input:  ILGenerator for the method
        // ForthStackIndex = ForthStackOrigin;
        // Output: None
        private void _SPstore(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldc_I4, this.ForthStackOrigin);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
        }

        // _RPstore - Flush return stack
        // Input:  ILGenerator for the method
        // ForthStackIndex = ReturnStackOrigin;
        // Output: None
        private void _RPstore(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldc_I4, this.ReturnStackOrigin);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
        }

        // _Fetch - Fetch the value from a given address
        // Input:  ILGenerator for the method
        // Dummy1 = ForthStack[ForthStackIndex - 1];
        // ForthStack[ForthStackIndex - 1] = ForthStack[Dummy1];
        // Output: None
        private void _Fetch(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _QuestionMark - Display the value from a given address
        // Input:  ILGenerator for the method
        // Console.Write(ForthStack[ForthStack[--ForthStackIndex]]);
        // Output: None
        private void _QuestionMark(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Call, this.WriteIntMethod);
        }

        // _Store - Stores a value at a given address
        // Input:  ILGenerator for the method
        // Dummy1 = ForthStack[ForthStackIndex - 2];
        // Dummy2 = ForthStack[ForthStackIndex - 1];
        // ForthStack[Dummy2] = Dummy1;
        // ForthStackIndex -= 2;
        // Output: None
        private void _Store(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
        }

        // _PlusStore - Adds a value at a given address
        // Input:  ILGenerator for the method
        // Dummy1 = ForthStack[ForthStackIndex - 2];
        // Dummy2 = ForthStack[ForthStackIndex - 1];
        // ForthStack[Dummy2] += Dummy1;
        // ForthStackIndex -= 2;
        // Output: None
        private void _PlusStore(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy3);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy3);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
        }

        // _Emit - Prints a char with the specified code
        // Input:  ILGenerator for the method
        // Console.Write((char)ForthStack[--ForthStackIndex]);
        // Output: None
        private void _Emit(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Conv_U2);
            ilgen.Emit(OpCodes.Call, this.WriteCharMethod);
        }

        // _Spaces - Prints a series of spaces
        // Input:  ILGenerator for the method
        // for(Dummy1 = 0; Dummy1 < ForthStack[--ForthStackIndex]; Dummy1++) Console.Write(' ');
        // Output: None
        private void _Spaces(ILGenerator ilgen)
        {
            var lb1 = ilgen.DefineLabel();
            var lb2 = ilgen.DefineLabel();

            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Br_S, lb1);
            ilgen.MarkLabel(lb2);
            ilgen.Emit(OpCodes.Ldc_I4_S, 32);
            ilgen.Emit(OpCodes.Call, this.WriteCharMethod);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy1);
            ilgen.MarkLabel(lb1);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Blt_S, lb2);
        }

        // _Type - Types a text
        // Input:  ILGenerator for the method
        // Dummy1 = ForthStack[ForthStackIndex - 2];
        // Dummy2 = ForthStack[ForthStackIndex - 1];
        // for(Dummy3 = Dummy1; Dummy3 < Dummy1 + Dummy2; Dummy3++) Console.Write((char)ForthStack[Dummy3]);
        // ForthStackIndex -= 2;
        // Output: None
        private void _Type(ILGenerator ilgen)
        {
            var lb1 = ilgen.DefineLabel();
            var lb2 = ilgen.DefineLabel();

            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy3);
            ilgen.Emit(OpCodes.Br_S, lb1);
            ilgen.MarkLabel(lb2);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy3);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Conv_U2);
            ilgen.Emit(OpCodes.Call, this.WriteCharMethod);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy3);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy3);
            ilgen.MarkLabel(lb1);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy3);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Blt_S, lb2);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
        }

        // _Pad - Pointer to a 64-cell area
        // Input:  ILGenerator for the method
        // ForthStack[ForthStackIndex++] = Pad;
        // Output: None
        private void _Pad(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4, this.Pad);   // PAD is at the end of the Forth stack
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _Tib - Pointer to a 80-cell area
        // Input:  ILGenerator for the method
        // ForthStack[ForthStackIndex++] = Tib;
        // Output: None
        private void _Tib(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4, this.Tib);   // TIB is before the PAD area
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _StackOrigin - Forth stack and return stack origin
        // Input:  ILGenerator for the method
        // ForthStack[ForthStackIndex++] = "ForthStackOrigin | ReturnStackOrigin";
        // Output: None
        private void _StackOrigin(ILGenerator ilgen, bool bForthStack)
        {
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
            if (bForthStack)
            {
                ilgen.Emit(OpCodes.Ldc_I4, this.ForthStackOrigin);
            }
            else
            {
                ilgen.Emit(OpCodes.Ldc_I4, this.ReturnStackOrigin);
            }

            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _Key - Places on the stack the code of the key pressed
        // Input:  ILGenerator for the method
        // ForthStack[ForthStackIndex++] = Console.Read();
        // Output: None
        private void _Key(ILGenerator ilgen)
        {
            var ReadCharMethod = typeof(Console).GetMethod("Read");
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Call, ReadCharMethod);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _Expect - Awaits characters and places them on the stack
        // Input:  ILGenerator for the method
        // Dummy1 = ForthStack[--ForthStackIndex];  // Max number of characters
        // Dummy2 = ForthStack[--ForthStackIndex];  // Address
        // while(Dummy1 > 0)
        // {
        // Dummy3 = Console.Read();
        // if(Dummy3 == 13)
        // {
        // ForthStack[Dummy2++] = 0;
        // break;
        // }
        // ForthStack[Dummy2++] = Dummy3;
        // Dummy1--;
        // }
        // Output: None
        private void _Expect(ILGenerator ilgen)
        {
            var ReadCharMethod = typeof(Console).GetMethod("Read");
            var lb1 = ilgen.DefineLabel();
            var lb2 = ilgen.DefineLabel();
            var lb3 = ilgen.DefineLabel();
            var lb4 = ilgen.DefineLabel();

            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Br_S, lb1);
            ilgen.MarkLabel(lb4);
            ilgen.Emit(OpCodes.Call, ReadCharMethod);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy3);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy3);
            ilgen.Emit(OpCodes.Ldc_I4, 13);
            ilgen.Emit(OpCodes.Bne_Un_S, lb2);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Br_S, lb3);
            ilgen.MarkLabel(lb2);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy3);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy1);
            ilgen.MarkLabel(lb1);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Bgt_S, lb4);
            ilgen.MarkLabel(lb3);
        }

        // _Query - Awaits 80 characters at the TIB area
        // Input:  ILGenerator for the method
        // Dummy1 = 80; // Max number of characters
        // Dummy2 = Tib;    // Address
        // while(Dummy1 > 0)
        // {
        // Dummy3 = Console.Read();
        // if(Dummy3 == 10)
        // {
        // ForthStack[Dummy2++] = 0;
        // break;
        // }
        // ForthStack[Dummy2++] = Dummy3;
        // Dummy1--;
        // }
        // Output: None
        private void _Query(ILGenerator ilgen)
        {
            var ReadCharMethod = typeof(Console).GetMethod("Read");
            var lb1 = ilgen.DefineLabel();
            var lb2 = ilgen.DefineLabel();
            var lb3 = ilgen.DefineLabel();
            var lb4 = ilgen.DefineLabel();

            ilgen.Emit(OpCodes.Ldc_I4_S, 80);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Ldc_I4, this.Tib);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Br_S, lb1);
            ilgen.MarkLabel(lb4);
            ilgen.Emit(OpCodes.Call, ReadCharMethod);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy3);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy3);
            ilgen.Emit(OpCodes.Ldc_I4, 10);
            ilgen.Emit(OpCodes.Bne_Un_S, lb2);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Br_S, lb3);
            ilgen.MarkLabel(lb2);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy3);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy1);
            ilgen.MarkLabel(lb1);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Bgt_S, lb4);
            ilgen.MarkLabel(lb3);
        }

        // _ToR - Transfers the element to the top of the return stack
        // Input:  ILGenerator for the method
        // ReturnStack[ReturnStackIndex++] = ForthStack[--ForthStackIndex];
        // Output: None
        private void _ToR(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, this.ReturnStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ReturnStackIndex);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, this.ReturnStackIndex);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _RFrom - Transfers the element from the return stack to the forth stack
        // Input:  ILGenerator for the method
        // ForthStack[ForthStackIndex++] = ReturnStack[--ReturnStackIndex];
        // Output: None
        private void _RFrom(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldsfld, this.ReturnStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ReturnStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Stsfld, this.ReturnStackIndex);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _I - Copies the top element from the return stack to the Forth stack
        // Input:  ILGenerator for the method
        // ForthStack[ForthStackIndex++] = ReturnStack[ReturnStackIndex - 1];
        // Output: None
        private void _I(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldsfld, this.ReturnStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ReturnStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _Isecond - Copies the second top element from the return stack to the Forth stack
        // Input:  ILGenerator for the method
        // ForthStack[ForthStackIndex++] = ReturnStack[ReturnStackIndex - 2];
        // Output: None
        private void _Isecond(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldsfld, this.ReturnStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ReturnStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _J - Copies the third top element from the return stack to the Forth stack
        // Input:  ILGenerator for the method
        // ForthStack[ForthStackIndex++] = ReturnStack[ReturnStackIndex - 3];
        // Output: None
        private void _J(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldsfld, this.ReturnStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ReturnStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_3);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _Fill - Fills an area
        // Input:  ILGenerator for the method
        // Dummy1 = ForthStack[ForthStackIndex - 1];    // c
        // Dummy2 = ForthStack[ForthStackIndex - 2];    // n
        // Dummy3 = ForthStack[ForthStackIndex - 3];    // addr
        // ForthStackIndex -= 3;
        // while(Dummy2-- > 0)
        // {
        // ForthStack[Dummy3++] = Dummy1;
        // }
        // Output: None
        private void _Fill(ILGenerator ilgen)
        {
            var lb1 = ilgen.DefineLabel();
            var lb2 = ilgen.DefineLabel();

            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_3);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy3);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_3);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Br_S, lb1);
            ilgen.MarkLabel(lb2);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy3);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy3);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.MarkLabel(lb1);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Bgt_S, lb2);
        }

        // _Erase - Fills an area
        // Input:  ILGenerator for the method
        // Dummy1 = ForthStack[ForthStackIndex - 1];    // n
        // Dummy2 = ForthStack[ForthStackIndex - 2];    // addr
        // ForthStackIndex -= 2;
        // while(Dummy1-- > 0)
        // {
        // ForthStack[Dummy2++] = "Value"; // 0 or 32
        // }
        // Output: None
        private void _Erase(ILGenerator ilgen, int FillValue)
        {
            var lb1 = ilgen.DefineLabel();
            var lb2 = ilgen.DefineLabel();

            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Br_S, lb1);
            ilgen.MarkLabel(lb2);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Ldc_I4, FillValue);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.MarkLabel(lb1);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Bgt_S, lb2);
        }

        // _Str2Int - Converts a string from TIB to a number on the stack
        // Input:  ILGenerator for the method
        // Dummy1 = Tib;
        // strDummy = "";
        // while(ForthStack[Dummy1] != 0)
        // {
        // strDummy += (char)ForthStack[Dummy1];
        // Dummy1++;
        // }
        // ForthStack[ForthStackIndex++] = Convert.ToInt32(strDummy);
        // Output: None
        private void _Str2Int(ILGenerator ilgen)
        {
            var lb1 = ilgen.DefineLabel();
            var lb2 = ilgen.DefineLabel();
            var exc = ilgen.DefineLabel();

            ilgen.BeginExceptionBlock();
            ilgen.Emit(OpCodes.Ldc_I4, this.Tib);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Ldstr, string.Empty);
            ilgen.Emit(OpCodes.Stsfld, this.strDummy);
            ilgen.Emit(OpCodes.Br_S, lb1);
            ilgen.MarkLabel(lb2);
            ilgen.Emit(OpCodes.Ldsfld, this.strDummy);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Conv_U2);
            ilgen.Emit(OpCodes.Box, typeof(char));
            ilgen.Emit(OpCodes.Call, typeof(string).GetMethod("Concat", new Type[] { typeof(object), typeof(object) }));
            ilgen.Emit(OpCodes.Stsfld, this.strDummy);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy1);
            ilgen.MarkLabel(lb1);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Brtrue_S, lb2);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldsfld, this.strDummy);
            ilgen.Emit(OpCodes.Call, typeof(Convert).GetMethod("ToInt32", new Type[] { typeof(string) }));
            ilgen.Emit(OpCodes.Stelem_I4);

            ilgen.BeginCatchBlock(typeof(FormatException));
            ilgen.EmitWriteLine("RUNTIME ERROR: Could not interpret the TIB area.");
            ilgen.Emit(OpCodes.Pop);
            ilgen.Emit(OpCodes.Ret);
            ilgen.EndExceptionBlock();
        }

        // _Count - Counts the number of non-zero consecutive characters
        // Input:  ILGenerator for the method
        // Dummy1 = Tib;
        // strDummy = "";
        // while(ForthStack[Dummy1] != 0)
        // {
        // strDummy += (char)ForthStack[Dummy1];
        // Dummy1++;
        // }
        // ForthStack[ForthStackIndex++] = Convert.ToInt32(strDummy);
        // Output: None
        private void _Count(ILGenerator ilgen)
        {
            var lb1 = ilgen.DefineLabel();
            var lb2 = ilgen.DefineLabel();

            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Br_S, lb1);
            ilgen.MarkLabel(lb2);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy1);
            ilgen.MarkLabel(lb1);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Brtrue_S, lb2);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _Dump - Dumps a string on the stack
        // Input:  ILGenerator for the method, string to dump on the stack
        // Dummy1 = ForthStack[--ForthStackIndex];      // Address
        // Dummy2 = strDummy.Length;
        // Dummy3 = 0;
        // while(Dummy2-- > 0)
        // {
        // ForthStack[Dummy1++] = strDummy[Dummy3++];
        // }
        // ForthStack[Dummy1] = 0;
        // Output: None
        private void _Dump(ILGenerator ilgen, string text)
        {
            var lb1 = ilgen.DefineLabel();
            var lb2 = ilgen.DefineLabel();

            ilgen.Emit(OpCodes.Ldstr, text);
            ilgen.Emit(OpCodes.Stsfld, this.strDummy);

            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, this.strDummy);
            ilgen.Emit(OpCodes.Callvirt, typeof(string).GetMethod("get_Length"));
            ilgen.Emit(OpCodes.Stsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy3);
            ilgen.Emit(OpCodes.Br_S, lb1);
            ilgen.MarkLabel(lb2);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, this.strDummy);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy3);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy3);
            ilgen.Emit(OpCodes.Callvirt, typeof(string).GetMethod("get_Chars", new Type[] { typeof(int) }));
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.MarkLabel(lb1);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Bgt_S, lb2);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _CMove - Dumps a string on the stack
        // Input:  ILGenerator for the method
        // Dummy1 = ForthStack[--ForthStackIndex];  // Count
        // Dummy2 = ForthStack[--ForthStackIndex];  // Destination
        // Dummy3 = ForthStack[--ForthStackIndex];  // Source
        // while(Dummy1-- > 0) ForthStack[Dummy2++] = ForthStack[Dummy3++];
        // Output: None
        private void _CMove(ILGenerator ilgen)
        {
            var lb1 = ilgen.DefineLabel();
            var lb2 = ilgen.DefineLabel();

            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy3);
            ilgen.Emit(OpCodes.Br_S, lb1);
            ilgen.MarkLabel(lb2);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy3);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy3);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.MarkLabel(lb1);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Bgt_S, lb2);
        }

        // _Int2Str - Converts an integer on the stack to a string
        // Input:  ILGenerator for the method
        // strDummy = (ForthStack[--ForthStackIndex]).ToString();   // Value to convert
        // Dummy1 = ForthStack[--ForthStackIndex];      // Address
        // Dummy2 = strDummy.Length;
        // Dummy3 = 0;
        // while(Dummy2-- > 0)
        // {
        // ForthStack[Dummy1++] = strDummy[Dummy3++];
        // }
        // ForthStack[Dummy1] = 0;
        // Output: None
        private void _Int2Str(ILGenerator ilgen)
        {
            var lb1 = ilgen.DefineLabel();
            var lb2 = ilgen.DefineLabel();

            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldelema, typeof(int));
            ilgen.Emit(OpCodes.Call, typeof(int).GetMethod("ToString", new Type[] { }));
            ilgen.Emit(OpCodes.Stsfld, this.strDummy);

            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, this.strDummy);
            ilgen.Emit(OpCodes.Callvirt, typeof(string).GetMethod("get_Length"));
            ilgen.Emit(OpCodes.Stsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy3);
            ilgen.Emit(OpCodes.Br_S, lb1);
            ilgen.MarkLabel(lb2);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, this.strDummy);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy3);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy3);
            ilgen.Emit(OpCodes.Callvirt, typeof(string).GetMethod("get_Chars", new Type[] { typeof(int) }));
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.MarkLabel(lb1);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, this.Dummy2);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Bgt_S, lb2);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.Dummy1);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _Exit    - Exits from the current word
        // Input:  ILGenerator for the method
        // Output: None
        private void _Exit(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ret);
        }

        // _If - Processes the IF atom
        // Input:  ILGenerator for the method
        // Output: None
        private void _If(ILGenerator ilgen)
        {
            var sIF = new IFDescriptor { Else = ilgen.DefineLabel(), End = ilgen.DefineLabel(), ElseUsed = false };

            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Brfalse, sIF.Else);

            this.IFStack.Push(sIF);
        }

        // _Else - Processes the ELSE atom
        // Input:  ILGenerator for the method
        // Output: None
        private void _Else(ILGenerator ilgen)
        {
            var sIF = this.IFStack.Pop();

            ilgen.Emit(OpCodes.Br, sIF.End);    // Avoid executing the False branch
            ilgen.MarkLabel(sIF.Else);
            sIF.ElseUsed = true;

            this.IFStack.Push(sIF);
        }

        // _Then - Processes the THEN atom
        // Input:  ILGenerator for the method
        // Output: None
        private void _Then(ILGenerator ilgen)
        {
            var sIF = this.IFStack.Pop();

            ilgen.MarkLabel(sIF.End);
            if (sIF.ElseUsed == false)
            {
                ilgen.MarkLabel(sIF.Else);
            }
        }

        // _Begin - Processes the BEGIN atom
        // Input:  ILGenerator for the method
        // Output: None
        private void _Begin(ILGenerator ilgen)
        {
            var sBEGIN = new BEGINDescriptor { Begin = ilgen.DefineLabel(), End = ilgen.DefineLabel() };
            ilgen.MarkLabel(sBEGIN.Begin);
            this.BEGINStack.Push(sBEGIN);
        }

        // _Until - Processes the UNTIL atom
        // Input:  ILGenerator for the method
        // Output: None
        private void _Until(ILGenerator ilgen)
        {
            var sBEGIN = this.BEGINStack.Pop();

            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Brfalse, sBEGIN.Begin);
        }

        // _Again - Processes the AGAIN atom
        // Input:  ILGenerator for the method
        // Output: None
        private void _Again(ILGenerator ilgen)
        {
            var sBEGIN = this.BEGINStack.Pop();
            ilgen.Emit(OpCodes.Br, sBEGIN.Begin);
        }

        // _While - Processes the WHILE atom
        // Input:  ILGenerator for the method
        // Output: None
        private void _While(ILGenerator ilgen)
        {
            var sBEGIN = this.BEGINStack.Peek();

            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Brfalse, sBEGIN.End);
        }

        // _Repeat - Processes the REPEAT atom
        // Input:  ILGenerator for the method
        // Output: None
        private void _Repeat(ILGenerator ilgen)
        {
            var sBEGIN = this.BEGINStack.Pop();
            ilgen.Emit(OpCodes.Br, sBEGIN.Begin);
            ilgen.MarkLabel(sBEGIN.End);
        }

        // _Case - Processes the CASE atom
        // Input:  ILGenerator for the method
        // Output: None
        private void _Case(ILGenerator ilgen)
        {
            var lbEndCase = ilgen.DefineLabel();
            this.CASEStack.Push(lbEndCase);
        }

        // _Of - Processes the OF atom
        // Input:  ILGenerator for the method
        // Output: None
        private void _Of(ILGenerator ilgen)
        {
            var lbEndOf = ilgen.DefineLabel();
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Bne_Un, lbEndOf);
            this.CASEStack.Push(lbEndOf);
        }

        // _EndOf - Processes the OF atom
        // Input:  ILGenerator for the method
        // Output: None
        private void _EndOf(ILGenerator ilgen)
        {
            var lbEndOf = this.CASEStack.Pop();
            var lbEndCase = this.CASEStack.Pop();
            ilgen.Emit(OpCodes.Br, lbEndCase);
            ilgen.MarkLabel(lbEndOf);
            this.CASEStack.Push(lbEndCase);
        }

        // _EndCase - Processes the ENDCASE atom
        // Input:  ILGenerator for the method
        // Output: None
        private void _EndCase(ILGenerator ilgen)
        {
            var lbEndCase = this.CASEStack.Pop();
            ilgen.MarkLabel(lbEndCase);
            this._Drop(ilgen);
        }

        // _Do - Processes the DO atom
        // Input:  ILGenerator for the method
        // Output: None
        private void _Do(ILGenerator ilgen)
        {
            var sDO = new DODescriptor { Do = ilgen.DefineLabel(), Loop = ilgen.DefineLabel() };
            this._Swap(ilgen);
            this._ToR(ilgen);
            this._ToR(ilgen);
            ilgen.MarkLabel(sDO.Do);
            this.DOStack.Push(sDO);
        }

        // _Leave - Processes the LEAVE atom
        // Input:  ILGenerator for the method
        // Output: None
        private void _Leave(ILGenerator ilgen)
        {
            var sDO = this.DOStack.Peek();

            // Clean up 2 elements from the return stack
            ilgen.Emit(OpCodes.Ldsfld, this.ReturnStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, this.ReturnStackIndex);

            ilgen.Emit(OpCodes.Br, sDO.Loop);
        }

        // _Loop - Processes the LOOP atom
        // Input:  ILGenerator for the method
        // Output: None
        private void _Loop(ILGenerator ilgen)
        {
            var sDO = this.DOStack.Peek();
            ilgen.Emit(OpCodes.Ldsfld, this.ReturnStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ReturnStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, this.DoLoopDummy);
            ilgen.Emit(OpCodes.Ldsfld, this.DoLoopDummy);
            ilgen.Emit(OpCodes.Ldsfld, this.ReturnStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ReturnStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);

            // The two following lines of code have been added in order to correct the behavior of the DO-LOOP structure which did not exit early enough
            // Ex. 5 0 DO I . LOOP; should print 01234 instead of 012345 as it was previously
            // Valer BOCAN, October 26, 2011
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);

            // End of change
            ilgen.Emit(OpCodes.Bge_S, sDO.Loop);
            ilgen.Emit(OpCodes.Ldsfld, this.ReturnStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ReturnStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, this.DoLoopDummy);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Br, sDO.Do);
            ilgen.MarkLabel(sDO.Loop);

            // Clean up 2 elements from the return stack
            ilgen.Emit(OpCodes.Ldsfld, this.ReturnStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, this.ReturnStackIndex);

            this.DOStack.Pop();
        }

        // _PlusLoop - Processes the +LOOP atom
        // Input:  ILGenerator for the method
        // Output: None
        private void _PlusLoop(ILGenerator ilgen)
        {
            var sDO = this.DOStack.Peek();
            ilgen.Emit(OpCodes.Ldsfld, this.ReturnStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ReturnStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, this.DoLoopDummy);
            ilgen.Emit(OpCodes.Ldsfld, this.DoLoopDummy);
            ilgen.Emit(OpCodes.Ldsfld, this.ReturnStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ReturnStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);

            // Valer BOCAN, October 26, 2011 (see explanation from the LOOP)
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);

            // End of change
            ilgen.Emit(OpCodes.Bge_S, sDO.Loop);
            ilgen.Emit(OpCodes.Ldsfld, this.ReturnStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ReturnStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, this.DoLoopDummy);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Stsfld, this.ForthStackIndex);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Br, sDO.Do);
            ilgen.MarkLabel(sDO.Loop);

            // Clean up 2 elements from the return stack
            ilgen.Emit(OpCodes.Ldsfld, this.ReturnStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, this.ReturnStackIndex);

            this.DOStack.Pop();
        }

        // CallExternalMethod - Calls a method from a class in an external file
        // Input:  ILGenerator for the method
        // FileName - the name of the file containing the class
        // ClassName - the name of the class
        // MethodName - the name of the method to call
        // Output: None
        private void CallExternalMethod(ILGenerator ilgen, string FileName, string ClassName, string MethodName)
        {
            if (!this.bExtCallerDefined)
            {
                // The runtime does not contain the ExternalCaller function, we add it here
                // Function ExternalCaller
                Type[] parameters = { typeof(string) /* FileName */, typeof(string) /* ClassName */, typeof(string) /* MethodName */ };
                this.extCaller = this.ForthEngineClass.DefineMethod("ExternalCaller", MethodAttributes.Private | MethodAttributes.Static, typeof(void), parameters);

                // Field calAssembly
                var calAssembly = this.ForthEngineClass.DefineField("CalleeAssembly", typeof(System.Reflection.Assembly), FieldAttributes.Private | FieldAttributes.Static);

                // Field calType
                var calType = this.ForthEngineClass.DefineField("CalleeType", typeof(System.Type), FieldAttributes.Private | FieldAttributes.Static);

                // Field calMethodInfo
                var calMethodInfo = this.ForthEngineClass.DefineField("CalleeMethodInfo", typeof(System.Reflection.MethodInfo), FieldAttributes.Private | FieldAttributes.Static);

                // Field calInstance
                var calInstance = this.ForthEngineClass.DefineField("CalleeInstance", typeof(object), FieldAttributes.Private | FieldAttributes.Static);

                var extCallerILGen = this.extCaller.GetILGenerator();

                // Define a few local labels
                var lb1 = extCallerILGen.DefineLabel();
                var lb2 = extCallerILGen.DefineLabel();
                var lb3 = extCallerILGen.DefineLabel();
                var lb4 = extCallerILGen.DefineLabel();
                var lb5 = extCallerILGen.DefineLabel();

                extCallerILGen.BeginExceptionBlock();
                extCallerILGen.Emit(OpCodes.Ldarg_0);
                extCallerILGen.Emit(OpCodes.Call, typeof(System.Reflection.Assembly).GetMethod("LoadFrom", new Type[] { typeof(string) }));
                extCallerILGen.Emit(OpCodes.Stsfld, calAssembly);
                extCallerILGen.Emit(OpCodes.Ldsfld, calAssembly);
                extCallerILGen.Emit(OpCodes.Ldarg_1);
                extCallerILGen.Emit(OpCodes.Ldc_I4_0);
                extCallerILGen.Emit(OpCodes.Ldc_I4_1);
                extCallerILGen.Emit(OpCodes.Callvirt, typeof(System.Reflection.Assembly).GetMethod("GetType", new Type[] { typeof(string), typeof(bool), typeof(bool) }));
                extCallerILGen.Emit(OpCodes.Stsfld, calType);
                extCallerILGen.Emit(OpCodes.Ldsfld, calType);
                extCallerILGen.Emit(OpCodes.Ldnull);
                extCallerILGen.Emit(OpCodes.Call, typeof(System.Type).GetMethod("op_Equality", new Type[] { typeof(System.Type), typeof(System.Type) }));
                extCallerILGen.Emit(OpCodes.Brfalse_S, lb1);
                extCallerILGen.EmitWriteLine("\n\rRUNTIME ERROR: Could not load library.");
                extCallerILGen.Emit(OpCodes.Br_S, lb2);
                extCallerILGen.MarkLabel(lb1);
                extCallerILGen.Emit(OpCodes.Ldsfld, calType);
                extCallerILGen.Emit(OpCodes.Ldarg_2);
                extCallerILGen.Emit(OpCodes.Callvirt, typeof(System.Type).GetMethod("GetMethod", new Type[] { typeof(string) }));
                extCallerILGen.Emit(OpCodes.Stsfld, calMethodInfo);
                extCallerILGen.Emit(OpCodes.Ldsfld, calMethodInfo);
                extCallerILGen.Emit(OpCodes.Ldnull);
                extCallerILGen.Emit(OpCodes.Call, typeof(System.Reflection.MethodInfo).GetMethod("op_Equality", new Type[] { typeof(System.Reflection.MethodInfo), typeof(System.Reflection.MethodInfo) }));
                extCallerILGen.Emit(OpCodes.Brfalse_S, lb3);
                extCallerILGen.EmitWriteLine("\n\rRUNTIME ERROR: Could not call external method.");
                extCallerILGen.Emit(OpCodes.Br_S, lb2);
                extCallerILGen.MarkLabel(lb3);
                extCallerILGen.Emit(OpCodes.Ldsfld, calMethodInfo);
                extCallerILGen.Emit(OpCodes.Callvirt, typeof(System.Reflection.MethodBase).GetMethod("get_IsStatic", new Type[] { }));
                extCallerILGen.Emit(OpCodes.Brtrue_S, lb4);
                extCallerILGen.Emit(OpCodes.Ldsfld, calType);
                extCallerILGen.Emit(OpCodes.Call, typeof(System.Activator).GetMethod("CreateInstance", new Type[] { typeof(System.Type) }));
                extCallerILGen.Emit(OpCodes.Stloc_0);
                extCallerILGen.Emit(OpCodes.Ldsfld, calMethodInfo);
                extCallerILGen.Emit(OpCodes.Ldloc_0);
                extCallerILGen.Emit(OpCodes.Ldnull);
                extCallerILGen.Emit(OpCodes.Callvirt, typeof(System.Reflection.MethodBase).GetMethod("Invoke", new Type[] { typeof(object), typeof(object[]) }));
                extCallerILGen.Emit(OpCodes.Pop);
                extCallerILGen.Emit(OpCodes.Br_S, lb2);
                extCallerILGen.MarkLabel(lb4);
                extCallerILGen.Emit(OpCodes.Ldsfld, calMethodInfo);
                extCallerILGen.Emit(OpCodes.Ldnull);
                extCallerILGen.Emit(OpCodes.Ldnull);
                extCallerILGen.Emit(OpCodes.Callvirt, typeof(System.Reflection.MethodBase).GetMethod("Invoke", new Type[] { typeof(object), typeof(object[]) }));
                extCallerILGen.Emit(OpCodes.Pop);
                extCallerILGen.MarkLabel(lb2);
                extCallerILGen.Emit(OpCodes.Leave_S, lb5);
                extCallerILGen.Emit(OpCodes.Pop);
                extCallerILGen.BeginCatchBlock(typeof(System.IO.FileNotFoundException));
                extCallerILGen.ThrowException(typeof(System.IO.FileNotFoundException));
                extCallerILGen.EndExceptionBlock();
                extCallerILGen.MarkLabel(lb5);
                extCallerILGen.Emit(OpCodes.Ret);

                this.bExtCallerDefined = true;
            }

            // ExternalCaller method is already defined in runtime, we just call it
            ilgen.Emit(OpCodes.Ldstr, FileName);
            ilgen.Emit(OpCodes.Ldstr, ClassName);
            ilgen.Emit(OpCodes.Ldstr, MethodName);
            ilgen.Emit(OpCodes.Call, this.extCaller);
        }
    }
}
